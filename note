#!/usr/bin/env python

import argparse
import os
import re
import subprocess
import sys
from datetime import datetime
from pyfzf.pyfzf import FzfPrompt

def parse_config() -> dict[str]:
    """
    Attempt to locate note config, returning a parsed version of it if found.

    returns:
        config read as dictionary. at least contains key 'note_dir',
        and may contain others
    raises:
        FileNotFoundError if config file is not in checked locations
        ValueError if 'note_dir' is not configured
    """
    # Attempt to find config directory
    conf_path = os.path.join(
        os.environ.get('APPDATA') or
        os.environ.get('XDG_CONFIG_HOME') or
        os.path.join(os.environ.get('HOME'), '.config'),
        'note',
        'config'
    )
    if (conf_path == os.path.join('note', 'config')):
        raise FileNotFoundError("No note config found!")

    config = {'extension': '.txt',
              'editor': 'vi'}

    # Set editor if $EDITOR is set (does not override config file)
    if (os.environ.get('EDITOR')): config['editor'] = os.environ.get('EDITOR')

    # Parse any config files to modify configuration
    with open(conf_path, 'r') as file:
        for line in file.readlines():
            # Skip any comments or blank lines
            stripped = line.strip()
            if (stripped[0] == '#' or stripped == ''):
                continue

            # Attempt to match stripped name used
            parts = [s.strip() for s in stripped.split('=')]
            match parts[0]:
                case 'note_dir':
                    # expand env vars in note_dir path, allowing $HOME but not ~
                    config['note_dir'] = os.path.expandvars(parts[1])
                case 'extension':
                    config['extension'] = parts[1]
                case 'editor':
                    config['editor'] = parts[1]
                case _:
                    print('note: Warning: Unrecognized configuration option: "' + parts[0] + '"') 

    # Raise error if no note_dir was set
    if ('note_dir' not in config):
        raise ValueError('No note directory was found, make sure to specify one in config.')
    return config

def filehead(file, n) -> list[str]:
    """
    Return the first n lines of an opened file in a list.

    args:
        file: a file that has been opened with open()
        n: the number of lines to get
    returns:
        a list containing the first three lines of the file
    """
    num_lines = 0
    head = []
    for line in file:
        if (num_lines > n):
            break
        head.append(line)
        num_lines += 1
    return head

def note_list(args):
    """
    List notes from note directory, in long or short format and with filters
    according to cli arguments.

    args:
        args: Parsed command line args from argparse
    """
    conf = parse_config()

    # Compile regex now
    tags_re  = re.compile('^Tags:\s*(.*?)$')
    if (args.long):
        title_re = re.compile('^Title:\s*(.*?)$')
        date_re  = re.compile('^Date:\s*(.*?)$')
    for filename in os.listdir(conf['note_dir']):
        # Parse title, date, and tags from file if they exist
        f_title = ""
        f_date = ""
        f_tags = []
        with open(os.path.join(conf['note_dir'], filename), 'r') as file:
            # Header will never take up more than 3 lines
            head = filehead(file, 3)
            for line in head:
                tags_match  = tags_re.findall(line)
                if (tags_match):
                    f_tags = tags_match[0].split()
                    continue
                if (args.long):
                    title_match = title_re.findall(line)
                    if (title_match):
                        f_title = title_match[0]
                        continue
                    date_match  = date_re.findall(line)
                    if (date_match):
                        f_date = date_match[0]
                        continue

        # Only print if arg 'tags' not provided or if note's tags match
        if (args.tags == None or all(x in f_tags for x in args.tags)):
            # Always print filename
            print(f'{filename}', end="")
            # Include tags on same line if not long printing
            if (not args.long and f_tags):
                print(" - ", end="")
                print(*f_tags, end="")
            print()
            # Print either field or -- when long printing
            if (args.long):
                print('  Title: ', end='')
                print(f_title) if f_title else print('--')
                print('  Date:  ', end='')
                print(f_date) if f_date else print('--')
                print('  Tags:  ', end='')
                print(*f_tags) if f_tags else print('--')

def fzf(options):
    return None

def note_edit(args):
    """
    Allow the user to fzf the titles of their notes. Can also filter by tags
    if specified in args.

    args:
        args: Parsed command line args from argparse
    """
    conf = parse_config()

    to_select = []
    tags_re  = re.compile('^Tags:\s*(.*?)$')
    for filename in os.listdir(conf['note_dir']):
        f_tags = []
        with open(os.path.join(conf['note_dir'], filename), 'r') as file:
            # Header will never take up more than 3 lines
            head = filehead(file, 3)
            for line in head:
                tags_match  = tags_re.findall(line)
                if (tags_match):
                    f_tags = tags_match[0].split()
                    break
        if (args.tags == None or all(x in f_tags for x in args.tags)):
            to_select.append(filename)

    sel = FzfPrompt().prompt(to_select)
    if (sel): subprocess.run([conf['editor'], os.path.join(conf['note_dir'], sel[0])])

def note_new(args):
    """
    Create a new note with a name based on today's date, as well an optional
    title and tags.

    args:
        args: Parsed command line args from argparse
    raises:
        FileExistsError if the note that would be created already exists
    """
    conf = parse_config()
    note_name = datetime.today().strftime('%Y%m%d')
    if (args.name):
        note_name += "-" + args.name
    note_path = os.path.join(conf['note_dir'], note_name + conf['extension'])

    # Refuse to change an existing note file
    if (os.path.exists(note_path)):
        raise FileExistsError(f'Note with title "{note_name}" already exists, did you want note edit?')

    # Prompt user to create note if -y flag is not passed
    if (not args.yes):
        answer = ''
        while (True):
            answer = input('Create note "' + note_name + conf['extension'] + '"? [Y/n]: ')
            match answer.lower():
                case '':
                    create = True
                    break
                case 'y':
                    create = True
                    break
                case 'n':
                    create = False
                    break
                case _:
                    continue

        # Return now if the user does not want to create the file
        if (not create):
            return

    with open(note_path, 'w') as note_file:
        # Write blank title, today's date, and any specified tags
        note_file.write("Title: \n")
        note_file.write('Date:  ' + datetime.today().strftime('%Y-%m-%d') + "\n")
        note_file.write('Tags: ')
        if (args.tags): [note_file.write(" " + tag) for tag in args.tags]

        # Write ====== divider across
        note_file.write('\n\n')
        [note_file.write('=') for _ in range(80)]
        note_file.write('\n\n')
    subprocess.run([conf['editor'], note_path])

def main(sys_args) -> int:
    """
    Run when __name__ is __main__. Parses cli arguments and runs the
    appropriate subfunction.

    args:
        sys_args: CLI arguments (sys.argv)
    returns:
        system exit status (0 success, nonzero failure)
    excepts:
        FileExistsError, FileNotFoundError, ValueError: prints error message
        and returns nonzero exit status
    """
    parser = argparse.ArgumentParser(description='Note management utility')

    subparsers = parser.add_subparsers(required=True)
    parser_list = subparsers.add_parser('list', aliases=['ls', 'l'], help='list notes')
    parser_edit = subparsers.add_parser('edit', aliases=['e'], help='edit existing note')
    parser_new  = subparsers.add_parser('new', aliases='n', help='create new note')

    # List
    parser_list.add_argument('-t', '--tags', nargs='+',
                             help='filter notes with tags', metavar='TAG')
    parser_list.add_argument('--long', action='store_true',
                             help='print long listings')
    parser_list.set_defaults(func=note_list)

    # Edit
    parser_edit.add_argument('-t', '--tags', nargs='+',
                             help='filter notes with tags', metavar='TAG')
    parser_edit.set_defaults(func=note_edit)

    # New
    parser_new.add_argument('name', nargs='?',
                            help='name to include in filename')
    parser_new.add_argument('-t', '--tags', nargs='+',
                            help='tags to create note with', metavar='TAG')
    parser_new.add_argument('-y', '--yes', required=False, action='store_true',
                            help='create note without confirmation')
    parser_new.set_defaults(func=note_new)

    # Parse args and pass them to the appropriate func
    args = parser.parse_args(sys_args[1:])
    
    # Handle intentionally raised errors by printing cleanly
    try:
        args.func(args)
    except (FileExistsError, FileNotFoundError, ValueError) as e:
        print("note: Error: " + str(e))
        return 1

    # Normal exit
    return 0

if __name__ == '__main__':
    # Inform system of exit status
    sys.exit(main(sys.argv))
