#!/usr/bin/env python

import argparse
import os
import re
import subprocess
import sys
from datetime import datetime
from pyfzf.pyfzf import FzfPrompt

def locate_config():
    # $XDG_CONFIG_HOME/note/config
    if ('XDG_CONFIG_HOME' in os.environ and os.path.exists(os.environ.get('XDG_CONFIG_HOME') + '/note/config')):
        return os.environ.get('XDG_CONFIG_HOME') + '/note/config'
    # $HOME/.config/note/config
    elif (os.path.exists(os.environ.get('HOME') + '/.config/note/config')):
        return os.environ.get('HOME') + '/.config/note/config'
    # $HOME/.note.conf
    elif (os.path.exists(os.environ.get('HOME') + '/.note.conf')):
        return os.environ.get('HOME') + '/.note.conf'
    else:
        raise FileNotFoundError("No note config found!")

def parse_config():
    config = {'extension': '.txt',
              'editor': 'vi'}

    # Parse any config files to modify configuration
    conf_fname = locate_config()
    with open(conf_fname, 'r') as file:
        for line in file.readlines():
            # Skip any comments or blank lines
            stripped = line.strip()
            if (stripped[0] == '#' or stripped == ''):
                continue

            # Attempt to match stripped name used
            # TODO how do I deal with invalid values for valid configs?
            parts = [s.strip() for s in stripped.split('=')]
            match parts[0]:
                case 'note_dir':
                    config['note_dir'] = parts[1]
                case 'extension':
                    config['extension'] = parts[1]
                case 'editor':
                    config['editor'] = parts[1]
                case _:
                    print(sys.argv[0] + ': Warning: Unrecognized configuration option: "' + parts[0] + '"') 

    # Raise error if no note_dir was set
    if ('note_dir' not in config):
        raise ValueError('No note directory was found, make sure to specify one in config.')
    return config

def filehead(file, n):
    num_lines = 0
    head = []
    for line in file:
        if (num_lines > 2):
            break
        head.append(line)
        num_lines += 1
    return head

def note_list(args):
    conf = parse_config()

    # Compile regex now
    if (args.long):
        title_re = re.compile('^Title:\s*(.*?)$')
        date_re  = re.compile('^Date:\s*(.*?)$')
    tags_re  = re.compile('^Tags:\s*(.*?)$')
    for filename in os.listdir(conf['note_dir']):
        # Parse title, date, and tags from file if they exist
        f_title = ""
        f_date = ""
        f_tags = []
        with open(os.path.join(conf['note_dir'], filename), 'r') as file:
            # Header will never take up more than 3 lines
            head = filehead(file, 3)
            for line in head:
                tags_match  = tags_re.findall(line)
                if (tags_match):
                    f_tags = tags_match[0].split()
                    continue
                if (args.long):
                    title_match = title_re.findall(line)
                    if (title_match):
                        f_title = title_match[0]
                        continue
                    date_match  = date_re.findall(line)
                    if (date_match):
                        f_date = date_match[0]
                        continue

        # Only print if arg 'tags' not provided or if note's tags match
        if (args.tags == None or all(x in f_tags for x in args.tags)):
            # Always print filename
            print(f'{filename}', end="")
            # Include tags on same line if not long printing
            if (not args.long and f_tags):
                print(" - ", end="")
                print(*f_tags, end="")
            print()
            # Print either field or -- when long printing
            if (args.long):
                print('  Title: ', end='')
                print(f_title) if f_title else print('--')
                print('  Date:  ', end='')
                print(f_date) if f_date else print('--')
                print('  Tags:  ', end='')
                print(*f_tags) if f_tags else print('--')

def note_edit(args):
    conf = parse_config()

    to_select = []
    tags_re  = re.compile('^Tags:\s*(.*?)$')
    for filename in os.listdir(conf['note_dir']):
        f_tags = []
        with open(os.path.join(conf['note_dir'], filename), 'r') as file:
            # Header will never take up more than 3 lines
            head = filehead(file, 3)
            for line in head:
                tags_match  = tags_re.findall(line)
                if (tags_match):
                    f_tags = tags_match[0].split()
                    break
        if (args.tags == None or all(x in f_tags for x in args.tags)):
            to_select.append(filename)

    fzf = FzfPrompt()
    sel = fzf.prompt(to_select)
    if (sel): subprocess.run([conf['editor'], os.path.join(conf['note_dir'], sel[0])])

def note_new(args):
    conf = parse_config()
    note_name = datetime.today().strftime('%Y%m%d')
    if (args.name):
        note_name += "-" + args.name
    note_path = os.path.join(conf['note_dir'], note_name + conf['extension'])

    # Refuse to change an existing note file
    if (os.path.exists(note_path)):
        raise FileExistsError(f'Note with title "{note_name}" already exists, did you want {sys.argv[0]} edit?')

    with open(note_path, 'w') as note_file:
        # Write blank title, today's date, and any specified tags
        note_file.write("Title: \n")
        note_file.write('Date:  ' + datetime.today().strftime('%Y-%m-%d') + "\n")
        note_file.write('Tags: ')
        if (args.tags): [note_file.write(" " + tag) for tag in args.tags]

        # Write ====== divider across
        note_file.write('\n\n')
        [note_file.write('=') for _ in range(80)]
        note_file.write('\n\n')
    subprocess.run([conf['editor'], note_path])

def main(str_args):
    parser = argparse.ArgumentParser(description='Note management utility')

    subparsers = parser.add_subparsers(required=True)
    parser_list = subparsers.add_parser('list', aliases=['ls'], help='list notes')
    parser_edit = subparsers.add_parser('edit', aliases=['e'], help='edit existing note')
    parser_new  = subparsers.add_parser('new', aliases='n', help='create new note')

    # List
    parser_list.add_argument('-t', '--tags', nargs='+',
                             help='filter notes with tags', metavar='TAG')
    parser_list.add_argument('--long', action='store_true',
                             help='print long listings')
    parser_list.set_defaults(func=note_list)

    # Edit
    parser_edit.add_argument('-t', '--tags', nargs='+',
                             help='filter notes with tags', metavar='TAG')
    parser_edit.set_defaults(func=note_edit)

    # New
    parser_new.add_argument('name', nargs='?',
                            help='optional note name')
    parser_new.add_argument('-t', '--tags', nargs='+',
                            help='initial note tags', metavar='TAG')
    parser_new.set_defaults(func=note_new)

    # Parse args and pass them to the appropriate func
    args = parser.parse_args(str_args)
    
    # Handle intentionally raised errors by printing cleanly
    try:
        args.func(args)
    except (FileExistsError, FileNotFoundError, ValueError) as e:
        print(sys.argv[0] + ": Error: " + str(e))
        return 1

    # Normal exit
    return 0

if __name__ == '__main__':
    # Inform system of exit status
    sys.exit(main(sys.argv[1:]))
