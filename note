#!/usr/bin/env python

import argparse
import sys
import os

def locate_config():
    # $XDG_CONFIG_HOME/note/config
    if ('XDG_CONFIG_HOME' in os.environ and os.path.exists(os.environ.get('XDG_CONFIG_HOME') + '/note/config')):
        return os.environ.get('XDG_CONFIG_HOME') + '/note/config'
    # $HOME/.config/note/config
    elif (os.path.exists(os.environ.get('HOME') + '/.config/note/config')):
        return os.environ.get('HOME') + '/.config/note/config'
    # $HOME/.note.conf
    elif (os.path.exists(os.environ.get('HOME') + '/.note.conf')):
        return os.environ.get('HOME') + '/.note.conf'
    else:
        raise FileNotFoundError("No note config found!")

def parse_config():
    conf_fname = locate_config()
    # Default config
    config = {'extension': '.txt',
              'editor': 'vi'}
    # TODO for now, this is bound to a relative path.
    # I wanna do it like ~/.note.conf or $XDG_CONFIG_HOME/note/config
    # Parse any config files to modify configuration
    with open(conf_fname, 'r') as file:
        for line in file.readlines():
            stripped = line.strip()
            parts = [s.strip() for s in line.split('=')]
            # TODO use a match statement or whatever fancy thing that is
            if (stripped[0] == '#' or stripped == ''):
                # Skip comments and whitespace lines
                pass
            elif (parts[0] == 'note_dir'):
                config['note_dir'] = parts[1]
            elif (parts[0] == 'extension'):
                config['extension'] = parts[1]
            elif (parts[0] == 'editor'):
                config['editor'] = parts[1]
            else:
                print(sys.argv[0] + ': Warning: Unrecognized configuration option: "' + parts[1] + '"') 

    if (not config.get('note_dir')):
        raise ValueError('No note directory was found, make sure to specify one in config.')
    return config

def note_list(args):
    tags = [] if args.tags == None else args.tags
    conf = parse_config()
    print(conf)
    print("note list not yet implemented")
    print(args)

def note_edit(args):
    tags = [] if args.tags == None else args.tags
    print("note edit not yet implemented")
    print(args)

def note_new(args):
    tags = [] if args.tags == None else args.tags
    print("note new not yet implemented")
    print(args)

def main(str_args):
    parser = argparse.ArgumentParser(description='Note management utility')

    subparsers = parser.add_subparsers(required=True)
    parser_list = subparsers.add_parser('list', aliases=['ls'], help='list notes')
    parser_edit = subparsers.add_parser('edit', aliases=['e'], help='edit existing note')
    parser_new  = subparsers.add_parser('new', aliases='n', help='create new note')

    # List
    parser_list.add_argument('-t', '--tags', nargs='+',
                             help='filter notes with tags', metavar='TAG')
    parser_list.add_argument('--long', action='store_true',
                             help='print long listings')
    parser_list.set_defaults(func=note_list)

    # Edit
    parser_edit.add_argument('-t', '--tags', nargs='+',
                             help='filter notes with tags', metavar='TAG')
    parser_edit.set_defaults(func=note_edit)

    # New
    parser_new.add_argument('name', nargs='?',
                            help='optional note name')
    parser_new.add_argument('-t', '--tags', nargs='+',
                            help='initial note tags', metavar='TAG')
    parser_new.set_defaults(func=note_new)

    # Parse args and pass them to the appropriate func
    args = parser.parse_args(str_args)
    
    # Handle intentionally raised errors by printing cleanly
    try:
        args.func(args)
    except (FileNotFoundError, ValueError) as e:
        print(sys.argv[0] + ": Error: " + str(e))
        return 1

    # Normal exit
    return 0

if __name__ == '__main__':
    # Inform system of exit status
    sys.exit(main(sys.argv[1:]))
